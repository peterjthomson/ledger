/**
 * Core AI Types
 *
 * Shared types for the AI infrastructure supporting Anthropic, OpenAI, and Gemini.
 */

export type AIProvider = 'anthropic' | 'openai' | 'gemini' | 'openrouter'

export interface AIMessage {
  role: 'user' | 'assistant' | 'system'
  content: string | AIContentBlock[]
}

export interface AIContentBlock {
  type: 'text' | 'image'
  text?: string
  imageUrl?: string
  imageBase64?: string
  mimeType?: string
}

export interface CompletionOptions {
  /** Override the default model */
  model?: string
  /** Override the default provider */
  provider?: AIProvider
  /** Maximum tokens to generate */
  maxTokens?: number
  /** Temperature (0-1) for response randomness */
  temperature?: number
  /** Sequences that will stop generation */
  stopSequences?: string[]
  /** Request JSON output (where supported) */
  jsonMode?: boolean
  /** System prompt to set context */
  systemPrompt?: string
}

export interface StreamCallbacks {
  /** Called for each chunk of streamed text */
  onChunk: (text: string) => void
  /** Called when streaming completes */
  onComplete?: (fullText: string) => void
  /** Called on error during streaming */
  onError?: (error: Error) => void
}

export interface AIResponse {
  /** The generated content */
  content: string
  /** The model that was used */
  model: string
  /** The provider that was used */
  provider: AIProvider
  /** Token usage and cost information */
  usage: AIUsage
  /** Why generation stopped */
  finishReason: 'complete' | 'length' | 'stop' | 'error'
}

export interface AIUsage {
  inputTokens: number
  outputTokens: number
  /** Estimated cost in USD */
  estimatedCost: number
}

/**
 * Provider interface that all AI providers must implement
 */
export interface AIProviderInterface {
  /** Provider identifier */
  readonly provider: AIProvider

  /** Check if the provider is configured with valid credentials */
  isConfigured(): boolean

  /** Reset the provider, clearing credentials and client state */
  reset(): void

  /** Send a completion request */
  complete(messages: AIMessage[], options: CompletionOptions): Promise<AIResponse>

  /** Stream a completion request */
  stream(
    messages: AIMessage[],
    callbacks: StreamCallbacks,
    options: CompletionOptions
  ): Promise<void>
}

/**
 * Analysis types supported by the AI service
 */
export type AnalysisType =
  | 'card-completeness' // Evaluate how ready a card is for implementation
  | 'commit-summary' // Summarize a commit's changes
  | 'pr-review' // Review a PR for issues
  | 'diff-explanation' // Explain what a diff does
  | 'branch-summary' // Summarize a branch's purpose

/**
 * Triage dimension for card completeness scoring
 */
export type TriageDimension =
  | 'problem-definition'
  | 'acceptance-criteria'
  | 'technical-context'
  | 'priority-urgency'
  | 'scope-boundaries'

/**
 * A triage question generated by AI
 */
export interface TriageQuestion {
  id: string
  question: string
  type: 'single-choice' | 'multi-choice' | 'text' | 'scale'
  options?: string[]
  /** Why this question matters */
  context?: string
  /** Which completeness dimension it addresses */
  dimension: TriageDimension
}

/**
 * Settings for an AI provider
 */
export interface AIProviderSettings {
  apiKey: string
  enabled: boolean
  /** Optional organization ID (OpenAI) */
  organization?: string
}

/**
 * AI settings stored in the settings service
 */
export interface AISettings {
  providers: {
    anthropic?: AIProviderSettings
    openai?: AIProviderSettings
    gemini?: AIProviderSettings
    openrouter?: AIProviderSettings
  }
  defaults: {
    provider: AIProvider
    models: {
      /** Fast responses (haiku, gpt-4o-mini, flash) */
      quick: string
      /** General use (sonnet, gpt-4o, pro) */
      balanced: string
      /** Complex tasks (opus, o1) */
      powerful: string
    }
  }
  usage?: {
    trackCosts: boolean
    monthlyBudget?: number
    history: AIUsageRecord[]
  }
}

/**
 * A record of AI usage for cost tracking
 */
export interface AIUsageRecord {
  date: string
  provider: AIProvider
  model: string
  inputTokens: number
  outputTokens: number
  estimatedCost: number
}
